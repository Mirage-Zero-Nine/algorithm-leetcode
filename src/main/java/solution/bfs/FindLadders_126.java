package solution.bfs;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

/**
 * Given two words (beginWord and endWord), and a dictionary's word list.
 * Find all shortest transformation sequence(s) from beginWord to endWord.
 * Only one letter can be changed at a time
 * Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
 * Note:
 * 1. Return an empty list if there is no such transformation sequence.
 * 2. All words have the same length.
 * 3. All words contain only lowercase alphabetic characters.
 * 4. No duplicates in the word list. beginWord and endWord are non-empty and are different.
 *
 * @author BorisMirage
 * Time: 2019/05/29 10:59
 * Created with IntelliJ IDEA
 */

public class FindLadders_126 {
    /**
     * BFS + DFS.
     * BFS to build the graph, with a hash map to maintain a list of all words that can be converted to current word in one step.
     * After BFS completed (graph building), implement DFS to construct all paths from end word to start word using the hasp map built in BFS.
     *
     * @param beginWord The starting word.
     * @param endWord   The target word.
     * @param wordList  The list of valid words to use in the ladder.
     * @return A list paths where each path represents the shortest ladder from beginWord to endWord. Returns an empty list if no such path exists.
     */
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {

        // corner case
        if (beginWord.equals(endWord)) {
            return new ArrayList<>();
        }

        Map<String, List<String>> map = new HashMap<>();
        Set<String> words = new HashSet<>(wordList);
        List<List<String>> output = new ArrayList<>();

        // BFS to build the graph and check if the shortest path exists
        if (bfs(beginWord, endWord, words, map)) {
            List<String> tmp = new ArrayList<>();
            tmp.add(endWord);

            // if the shortest path exists, implement DFS to construct the paths
            dfs(endWord, beginWord, tmp, output, map);
        }

        return output;
    }

    /**
     * Performs BFS to build a map of word dependencies.
     * The map stores, for each word, a list of its predecessors.
     * The BFS ensures it's through the shortest possible sequence of transformations.
     *
     * @param begin The starting word for the BFS.
     * @param end   The target word for the BFS.
     * @param words The set of valid words.
     * @param map   The map to store the word dependencies.
     * @return True if a path from begin to end exists, false otherwise.
     */
    private boolean bfs(String begin, String end, Set<String> words, Map<String, List<String>> map) {

        Queue<String> q = new LinkedList<>();
        q.add(begin);
        boolean found = false;
        while (!q.isEmpty()) {
            Set<String> usedWords = new HashSet<>();
            int size = q.size();
            for (int i = 0; i < size; i++) {

                String current = q.poll();
                if (current.equals(end)) {
                    found = true;
                }
                char[] arr = current.toCharArray();

                for (int j = 0; j < arr.length; j++) {
                    char tmp = arr[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        arr[j] = c;
                        String w = new String(arr);

                        if (c != tmp && words.contains(w)) {
                            List<String> previous;

                            // there may be multiple predecessors that could be converted to current word
                            if (!usedWords.contains(w)) {
                                previous = new ArrayList<>();
                                q.add(w);
                                usedWords.add(w);
                            } else {
                                previous = map.get(w);
                            }

                            // update the map to store all words that can be converted to current word for later DFS tracking
                            previous.add(current);
                            map.put(w, previous);
                        }
                    }
                    arr[j] = tmp;
                }
            }
            words.removeAll(usedWords);
        }

        return found;
    }

    /**
     * Performs DFS to construct the ladders from the map generated by BFS.
     * Starting at the endWord, it looks up the predecessors of the endWord in the map.
     * For each predecessor, it adds it to the beginning of the current list.
     * Recursively calls dfs to find the path from that predecessor back to the beginWord.
     *
     * @param begin  The current word in the DFS.
     * @param end    The target word.
     * @param tmp    The current ladder being constructed.
     * @param output The list to store the completed ladders.
     * @param map    The map of word dependencies generated by BFS.
     */
    private void dfs(String begin, String end, List<String> tmp, List<List<String>> output, Map<String, List<String>> map) {

        if (begin.equals(end)) {
            output.add(new ArrayList<>(tmp));
            return;
        }

        // the list contains all words that can be converted to current word with one char flip
        for (String s : map.get(begin)) {
            tmp.addFirst(s);

            // go through each of the predecessors until reaches the beginning word
            dfs(s, end, tmp, output, map);
            tmp.removeFirst();
        }
    }
}
